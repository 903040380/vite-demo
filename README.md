# vite

- 在 Vite 项目中，一个 import 语句即代表一个 HTTP 请求

- Vite 所倡导的 no-bundle 理念的真正含义: 利用浏览器原生 ES 模块的支持，实现开发阶段的 Dev Server，进行模块的按需加载，而不是先整体打包再进行加载

## css

### 原生缺点

- 开发体验欠佳。比如原生 CSS 不支持选择器的嵌套
- 样式污染问题。如果出现同样的类名，很容易造成不同的样式互相覆盖和污染
- 浏览器兼容问题。为了兼容不同的浏览器，我们需要对一些属性(如 transition)加上不同的浏览器前缀，比如 -webkit-、-moz-、-ms-、-o-，意味着开发者要针对同一个样式属性写很多的冗余代码
- 打包后的代码体积问题。如果不用任何的 CSS 工程化方案，所有的 CSS 代码都将打包到产物中，即使有部分样式并没有在代码中使用，导致产物体积过大

### 解决方案

- CSS 预处理器：主流的包括 Sass/Scss、Less 和 Stylus
- CSS Modules：能将 CSS 类名处理成哈希值，这样就可以避免同名的情况下样式污染的问题
- CSS 后处理器 PostCSS，用来解析和处理 CSS 代码，可以实现的功能非常丰富，比如将 px 转换为 rem、根据目标浏览器情况自动加上类似于--moz--、-o-的属性前缀等等
- CSS in JS 方案，主流的包括 emotion、styled-components 等等，顾名思义，这类方案可以实现直接在 JS 中写样式代码，基本包含 CSS 预处理器和 CSS Modules 的各项优点，非常灵活，解决了开发体验和全局样式污染的问题
- CSS 原子化框架，如 Tailwind CSS、Windi CSS，通过类名来指定样式，大大简化了样式写法，提高了样式开发的效率，主要解决了原生 CSS 开发体验的问题

## 静态资源

### 图片加载

- 在 HTML 或者 JSX 中，通过 img 标签来加载图片
- 在 CSS 中通过 background 属性加载图片
- 在 JavaScript 中，通过脚本的方式动态指定图片的 src 属

#### svg

我们通常也希望能将 svg 当做一个组件来引入，这样我们可以很方便地修改 svg 的各种属性，而且比 img 标签的引入方式更加优雅

React 项目使用 vite-plugin-svgr 插件。

### JSON

Vite 中已经内置了对于 JSON 文件的解析，底层使用@rollup/pluginutils 的 dataToEsm 方法将 JSON 对象转换为一个包含各种具名导出的 ES 模块

### Web Worker 脚本

引入的时候注意加上?worker 后缀，相当于告诉 Vite 这是一个 Web Worker 脚本文件

### 生产环境

#### 自定义部署域名

自动化的方式来实现地址的替换

#### 单文件 or 内联

在 Vite 中，所有的静态资源都有两种构建方式，一种是打包成一个单文件，另一种是通过 base64 编码的格式内嵌到代码中

对于比较小的资源，适合内联到代码中，一方面对代码体积的影响很小，另一方面可以减少不必要的网络请求，优化网络性能。而对于比较大的资源，就推荐单独打包成一个文件，而不是内联了，否则可能导致上 MB 的 base64 字符串内嵌到代码中，导致代码体积瞬间庞大，页面加载性能直线下降

Vite 中内置的优化方案是下面这样的:

如果静态资源体积 >= 4KB，则提取成单独的文件
如果静态资源体积 < 4KB，则作为 base64 格式的字符串内联

#### 图片压缩

vite-plugin-imagemin

#### 雪碧图优化

在实际的项目中我们还会经常用到各种各样的 svg 图标，虽然 svg 文件一般体积不大，但 **Vite 中对于 svg 文件会始终打包成单文件**，大量的图标引入之后会导致网络请求增加，大量的 HTTP 请求会导致网络解析耗时变长，页面加载性能直接受到影响。

> HTTP2 的**多路复用设计**可以解决大量 HTTP 的请求导致的网络加载性能问题，因此雪碧图技术在 HTTP2 并没有明显的优化效果，这个技术更适合在传统的 HTTP 1.1 场景下使用(比如本地的 Dev Server)

Vite 中提供了 import.meta.glob 的语法糖来解决批量导入的问题
`const icons = import.meta.glob('../../assets/icons/logo-\*.svg');`
